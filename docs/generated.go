// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/metadata"
	"github.com/rss3-network/protocol-go/schema/network"
	"github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// PostDecentralizedMetadataJSONBody defines parameters for PostDecentralizedMetadata.
type PostDecentralizedMetadataJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit    *int                    `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Metadata *metadata.Metadata      `json:"metadata,omitempty" validate:"required"`
	Network  *network.Network        `json:"network,omitempty" validate:"required"`
	Platform *decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool        `json:"success,omitempty"`
	Tag    *tag.Tag     `json:"tag,omitempty" validate:"required"`
	Type   *schema.Type `json:"type,omitempty" validate:"required"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostDecentralizedMetadataJSONRequestBody defines body for PostDecentralizedMetadata for application/json ContentType.
type PostDecentralizedMetadataJSONRequestBody PostDecentralizedMetadataJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Agent Data by Path
	// (GET /agentdata/{path})
	GetAgentData(ctx echo.Context, path string) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Batch Get Activities By Metadata
	// (POST /decentralized/metadata)
	PostDecentralizedMetadata(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Operator Info
	// (GET /operators)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /operators/activity_count)
	GetActivityCount(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAgentData converts echo context to params.
func (w *ServerInterfaceWrapper) GetAgentData(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAgentData(ctx, path)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// PostDecentralizedMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedMetadata(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/agentdata/:path", wrapper.GetAgentData)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.POST(baseURL+"/decentralized/metadata", wrapper.PostDecentralizedMetadata)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/operators/activity_count", wrapper.GetActivityCount)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9aW/jOBLoXxG0D5hdwHHk2w4w2HE63TvB6+7JizMz2O0NDFqibW4kUiNScTyN/PcH",
	"XhIl0Y7vPibdH2JbFKtYLBaLxTo+uz6JYoIhZtS9+OzGIAERZDApfRvHgM3HwPdJitk4gD7ELAEh+hMG",
	"vGEAqZ+gmCGC3Qv3FrIEwUfoAJ+hR8QQpM40IZHD5tChMfTRFMHAUb3V3ZoLn0AUh9C9cL2noB+A7mTa",
	"7A66bTAdBD0IgwH0WrDTajc6QasHwKDrtTtuzUUcGsfMrbkYRPx91albcxP4R4oSjh9LUlhzqT+HEeDY",
	"/p8ETt0L92/n+djP5dPs7/jKHOJQdfr8XFtJkykMYALYQekhJuF9+gDonz+ThATQf0D8p0cQpnywP5We",
	"/RSTsE6Jj0DoPtdcCoE/D0A0L7yT/fpTw+P/63EoBnZEYr7TtFlPSEGc5RitI2EAGUAhdaYkqZBPvu9c",
	"X5U4qt/2YLsZdHotOIGN6bTZAwPYHjTanV5r0oZep9Gf+kG33/F700Gr1QhajQGYwH6nPe31PdiycxoK",
	"1tKFLWPeirIE4Zl9wGincQ5nELMrwICj8MmHeg5idP7YOAdojDCDoR1x9W0f1DFkC5I87Mzq6v3i0ods",
	"DhOYRnasNch9efEmIYz4JPyo+rMNLw4Bm5IkOpCg093VV8yHenxYmXWje107wP2l1qkGl8mQtQNLKN1p",
	"Ud2ORtXlBCb+MVbQHylMlkLcETwOUYRYFeWRwGwpsMRpNIGJQ6aOfIc6C8TmCIuHmdRjxEnUOIvLquHp",
	"QQjApnQ3MNh2Oobi5ffi3eea+3RGQIzOfBLAGcRn8Ikl4IyBmZqNKUhDpnGRaFTgP4IQBYBxzCKEf2zU",
	"IvD0Y9NbS70YzOB64sVghjDgD8SsKwqaBGqspY6AsBtxbvirW9CmShoFvEwZO0n8NKEkWU8N2cZJKQwE",
	"OXLq1Fcwiep1Wwq8ka+9NHo9XgXFOq4AJdCXY9lERE0AHxzBTvbeqqHlHe+6h1xlPWw60BymdaxbSwM1",
	"6JWLv7lq8e+26rdf7+aCX7vSeVMrTQ6ka/yd/mMVI+SqxXbUUCoE3Xj2sV3nkOM8ktKxZtzG3pwPHDEY",
	"0T01jpreAEGSAA7w6WxGzvhvZ/QBxWdEjAWEZzHhemoiN9BNqRivUABKZDycanNUElr0mi9JPoqwD8cM",
	"RZAyEMWb0Y4ykDCEZ5qIiDpZD6soVwa07eK7y97cdOBliPbxp74P1yqRtr1GvcUJwVK6csiq722HOlLv",
	"PStOUN2NBDB309HrTmyjZmC24SqpaM4MzNasD97x1jPLMd90UjkA+5DEEtpxTMsYrhsU73rrUS1juPmw",
	"zuyDSjFD4barM425frDZqiwDOP6qLEN85gPnJytI2SUJkDSC5T8sx5eA+fN/QWYz0dFhNm7+mk8wg1ho",
	"VCCOQ+QLXff8f1Rqk/nY4oTEMNGvKbsX3W8/zIxdO8vz8hlxh4NZfirYTm0vaN0768RbYZ7hbGh826ph",
	"2eZ2gD2fL5EvqQxZtuKtl6CxnW2506gtYRuBrUVuRjUQhr9M3YtP23EQl5Tuc+1zTijDlHK/Oz0twnNL",
	"euawyeR/0GdSWJX5TEgqZ0KCpdhaJlxc6eMZV5JKW0+UhgzFIXQyqVO2LBUE4gr59wEyEAAGXuXfYeTf",
	"bpIrUrOwO/PreXSf78vM9sKGapyqM/Z5LkrT3VDKLOWHwsgU0nsJ1q9CQu4o5LjeeiiCasG7j7zNcVGi",
	"dkdcvlIpm+/weo3WtGXIAVgcY+TfZQwdRJ1sTBsK4/IV5xdWRKs3rq9K6F9CCT2kOelVAX1VQCXuQujR",
	"mGCqj+Pqy3h4fas+vyzmngv9jC9BoHDdSkJuQrK3SSKukyrEuZtDR4lvLuUjEPI1AgOHJA7HACBMHYTF",
	"5ubk5pe6W8C8pOZqam5OCWM4NvxkNw5lSeqzNIHy6tIJEWXFi5+6WyvtGFr7rHZrf3sf9V7ePFcEjNKD",
	"N+2Ua7xv8vu/nPM+ycHcb8Dz5rQuANX22GkabjBzy53mzU72vai4LdXuCAPhDZhBuplk2JhKhvbwl+Ht",
	"8pi/Lb6uYH9inrZS76vh52u+DWMQym3hZJvNEDtIQXYoTB5h4kDe1iG+nyYJDJzFHIXQiRPC8eZbM8uH",
	"VBqDUjDfEDxFs51mdws1VkK5EnaIPej+kQTwGk/J8dBVAA6AKXtHUhycVhPJNf4EUpImPhRYYsKcKcem",
	"hOTtaLSTQM7cQfSa/vTZ1Y5Q/DM/gbgX7mKxqIOJX8eQ1UHqlqxZKZuTRLZXd0Vvowg4vy8xltaD4vD+",
	"m3peyw/Qo/gA5dd5U367xg6dk4RdyJ/P9e/yayy/fET+HIZIaKx+ShmJYOK8QThYOrfIn4MkoAQ7FCyp",
	"Q+fizE4eYbKYw5DrcwvE5o5PKKM1B2E/TAPeTwIxqzkRSdgMzKA48HOpRZ0ghfKSDDohwTMngCHvmE9s",
	"CMXV9hwmzpykFNYV0rEF59EcOnNAHTELMOBdAnkzzF+naQwTgHEq/dEIdsQo5ih2Zgmfb+pMUsmoCeRC",
	"DwZWYJpcv88B+4E6GD6xf66j5O9D5w2JIsj56wPCiDKYOKMUOm/DECZLTjqEHQbCB+laKF3FSBQDvHTA",
	"hKRM8Gf4qCWUIJGmDcGaWhFvr6eKOoBv7sBHeGYdxXnOHJhv9elkrOxJTa/ZPvN6Z17zzmtfNFoXrX7d",
	"87z/uDWXISb8miQfyCUdx4RKWk+4JiCwRNgBDoYLZ04i6EyWDiaLunONKYMg4PzyA1W4OROAH5I0Zv6y",
	"eHZ3b0ejn9OJOAyFfGsbp0nIF4A7ZyymF+fnxQVzjuGCnue4n+Ocgc84GmeTFIWcDc8kvc58kFLxUHHB",
	"ecNre+1ev+EJ5YCff91E+AswYlufaoOcQhjIFZibS1ySMre2cmWjwL04xTBqLsIBfHIvPMOgwsc0F4Ql",
	"C8yPx1X8MqvBFIQUlmiRn58bvcagP+g0+4OVJOIqxTgTdo0y0Z5rL6o/R9E2c1H+bemZv5PkASY77+m7",
	"K5hv9CMO+wDqYTbxApPb0ah1pnSfzAx09i8yTuCUjucQBHQcAYTHJIYYxGj8AQbIZq8NgkRZu0pmo5ob",
	"oQhmXilVB/HScGq74JRv1wTDDQxfW4PQGsH4DQlDLmsmIRzGcUIeRcTRKaCl2q57AmCXaXIiSB+QsNGf",
	"ANJdAgJ4MlCYTmFyRGhvn/w5wDP4Hv2RokBK06PDIgCfAMyIgQcpOo4OaQHiI4L5F9fLMcA+vElITOhR",
	"RUUO7DfCjsnnXNo+woQeW0hkcI4sIjI4xxYQJqBji4fb0eiIvY9EpK04Wh11aiScKxjCo3K0BPMePRwf",
	"yJF5WQK5IfQEQBIyRSE8BZyn5dGh3MJHROEJwCxAEhwdzGgOkmMORggwebY8gRJsQLtMUDA70ciOvL0Z",
	"kI4sFAxI+c5zf4iD1x15gHi7w2AAfRSB0HyIMIMzsRu6MgPClCQRYPJJt53be4yG0hJr6T8GCYXBGEVg",
	"BsdpElobUQZwwBfixYFpDnEajUe6dw5pGU2IHYk0QYXB8u+1ajOVvmIDqhzkLH23lUfd1t1zBDP1+/A8",
	"L7o3+P1IEEY608gxOjfOkUeC8Ct+wGRxLOJkau6R+r8djTI/pcP3nh+jLJ6huywoIRIsVqNh5t/HW7gX",
	"n1wgnkBhd38kD9A9DnxpR6qC9xMIGIc+EQlepggLRw235vqcHKFbc9M4kE2UoxD/chQkxVGsiuIkXbo1",
	"l8KQI0OmfCPjXxnHUWOf4X04xK5Mb0yNC8IcB3HZQGE4da1uxLkXnU5X8VS/MqLvcwc6FMUkEYZkIw2D",
	"eMGtybQbF+4MsXk6qfskOk8obZ2pi4XzWA9kRhT3n4PMxr7zqCsWJgvHBpxTJiRJyILPgZxAwcCR5uRY",
	"eArSNI5D/mGB2DxIwOKA02Oap9awtUYlgZxF+AKvuaEYm3xO4WG5pmTOqmJGGXjggFOsP/khQNEBUSja",
	"hKoYTEWCCzADCFM+bWBCGUD4gBgUjSurVnSIKNML+3CwP+aOzBpcqna+mguSCWKJyLkEkgUEglvBI+DL",
	"bQKolIOCdGc0Agk78+dALPkJYj4Rn/yEUDqRwshI4TQFiQ8oE7JphglFVIwQQ+DW3AhQRgKx9jEEvAmJ",
	"GYoQ5W/GJFzOxLPsopCCR/7kkYZCWoRgKfqdhCmkD8uXhI7ONvUxy/NgEzjbSxczncOOOrJpQ1i7aDFc",
	"iDWySEBsbkHi++GYxTA2WHdmgrAh2A4I1ziKaHC/Zlz69vbNmchkwj80uh31qdds6N8aHf1jY9DtuTX3",
	"49ubs0a7cUAU76Q/enUN+YamWnOh1upr7ixXouSVrtQHa+oiWyXqq7nM0NTvCxnR8r7W8TcDs/odmB2M",
	"r0VM/eZu7TuSs2o8OakuWDGnVKEHMCZUZKw57Ha99hb1eIdOaabg54VykNEmITaH1vjLvgo5/5dO7/cH",
	"I3GaDfToFD4uJQtnl+qE+oSyg0+nGtvz8eZHWBpPMTnHGoAwYH7LA5BXf9/8+jCV7O9mdWQ262+Owao+",
	"Ghen3IJWHeD5XPEBbx5cuzNBS/599p0vQ+cgdxJ2r5UvQ/jcIPFcc0Ek4pGPRmqujQMGE6lKHWmRW6fP",
	"gHycKdQeQV9kFov2m+eaG8MEkaCKDMTF2yt+UD1jKIK2ax2ROW7T5iXCy3drAqCN4Exfy52SCSTQI83/",
	"AsRVeksf76NJLnK6vXIfGlmczCqUmpBgab2DhDgYT0LiP1ifytvYys8hwvb28qBc3FYqjcoe34KZVyJR",
	"4jYUHJjDSl5zJxUwVuusEORqn6heeycQKNfyKl2PsujX+jKeUhQUvQ6/OVWw6Mz47aJ/uoPS6dah9Y5C",
	"rMNv57xU9S395njsdjSyyF8dfWlsKcUWKzyBbJtseespRM3YfImyyLxNtToVpXecMJcV7rfHm+hVbqUH",
	"nfaCj+93MRbhSPxdjOTIm9UJR3KjZLlNuqx0E1ypNquwv7Fy4as8nwMchHb/xEjHzx3H8CLD8yyyLpZX",
	"reMVOn2cTnT04qomifRdPtqBi6ZRBBI7wXXuvc2PFQwkM8iOpw8XWFZBW8lIhcxXG3i3nnIb0X78Jz36",
	"2K7/n2trHYcniNiPsE8xklyz2Ra9Zm1qp2H7on6Adt5c7Yq8fslljr2nmeSn5Rea4ifD7hznzHaa2BQO",
	"8Wk5Xs1Yx6C2Cib5LjbO20zqf/tjkWEx3/hQbLE3J13Yq/1X+CYukvmMN8whup9fX77vngzckQ3rB5RE",
	"1aCpL8UkBSejVxb5OlnkmzSqlkPovuUBfHN2u0qsUsV7Ubh4Tjhn1dxIus8yYT5Wjp8yfAOkZf+3PRwM",
	"i+FlBkZh5oIhbpwepC8pXQif4pCAQ8I3QogMDGJ9bVJzH8mh4mZKAVcFx/q1dD8cdB2OZYYVQBgcEIKK",
	"tjPdw5Xps+YG0m6YDTQmIpJAnzOU/i/daJF0QZYKbc2lQhusuSF6OORsmNGHK5aE3I8ta+PQc6MdyS3e",
	"2zYgtiT2ZlXLhlc7ZLXeQi1ar+ZG4AlFHMumJ4givzQqBpLtiu6uq65rKVtbGO+B0FhVyTYDn7I5xEzZ",
	"36zFECClY2WA2CxpmEhjKqo+29WGrCUIQ3vCt1sYJ5Dy7mVaRBCGDm/pACoc+JlONglwNr3V1MXTFMsy",
	"CnNA5/ascvwJZxsORTcX4GBQt1lwVIi3bmrvVDbK+8MggtbeErBYkbEZLAQWfMx1q0/OaqIWcraVEpEW",
	"i5x++iwzBY7VrX+j0Wur5IEwGFMmeKbptRvdvtc3cwkaEUdG6sbfRu9VlAqDpbcHYudjKRVzCwIuFSWz",
	"fioHYixEsjv3QsUdya/CjpWBPfOJSjFRQL/ZaPXbnV5lBJ3BoNdu9VvmCPJwJ2MAb9JEhT2YQ5CvD5pr",
	"hmCGjKwYja/6NsejkDiTzyrj6Q56/X63MpxGu9dp9TvmaPIoMmM0H5DIglsejny9u2Y0KkTGxD7SfZno",
	"K6hn6uHzfc01yr9q5soRL6SjNILRDJyNX4tYe1vim/djYqx/Vgx0L4OCLtZjKuOGDCTzEKnNceSdmAiq",
	"ILvn50q69fV1iLlwKDRxZJdmEdRtUmLmqSVtFxlrqvlyRLLHR0UioTt1tF5GGltUNUPmC1fziI5z16Ps",
	"+YSQEIocdSut9auuVvIaKtsY6gu+aQZKNV0qVb5bVJvu11Flr1r27hqlzlqhzspSIjmt3pALOztgDCa8",
	"mff0yTsbgLPp8Ozd/ee297wF5FUV7TNtA2AH4QA9oiAFoVImtS65XtfYwCH0pYJ9Zurv3crXHbDMWzH/",
	"cplkwywf76+376mjGuts3pJuBTnwUqqZ6h3qbFsy3IHZZs6zmxVO3KV80TqhY69AUlTQLAnivaegHwy7",
	"l++a3UG3Dd4NrnrwbTCAXuttp9VudK5aPTAcdL12p5w8Xt87ud5Tb9BtX3aHffC2A3qNtjeAvbeNHuhM",
	"mt3uYOC1hs3eYNAb+q6ZJKnRzyoU34RgeUWEgpPnL8ojhHWmIffm/fDfmeThhyDrvyp75em9hY5HfYDr",
	"iJyzp3Pvqd/2YLsZdHotOIGN6bTZAwPYHjTanV5r0oZep9Gf+kG33/F700Gr1QhajQGYwH6nPe31PdjK",
	"03qbupnKXe09wembzrTX8zvDq87VZb8z8Zv93tu+F/T91mW/77emzV6323yTMy0zE1n5xhmmdN5wvae2",
	"12xOeh1YqqumE4VDOekqOMNtNTrdwWDQ6bSa3qDr5ZPB5+K5lnPE5fCyHTSmzd5kOOz1uk3QDvrN5mXf",
	"e9Nt9971Gp1Bs9keNKc66fgBiGhPKm4cBHRa8a34NUs5zpIUrpimQubxfrc/6DV72extwdjlrOSeZUJr",
	"1msK+nJG8hUmh/2LPRFsk44m1210JtftD1bfT/HuZmVqBP8fYodEKzTRFKM/UuigAGKGpggmWX15cyaq",
	"mpxkaVuP4lFZEXHU9PKZr9tzw21XwLBS7TVbR1spR1UzxcGKveaVBIv4XOMA+aKKx2IupECRUOXU7zWL",
	"mrzHFr9XdcQDKAhFUWKbK9FkM7uknZNOoITcGFxSzf/RQNifuzV3OPztLf8DHuGMMH/O1bdhnsHmUias",
	"uYQ4uBr+4tbcNyIf0xsjQY22q7z9OHJr7jsjR83PaDYP0WzOd8Pr//c7euCd/1+0QCI1iVtz30PMT9/v",
	"UUDEH5nJ5j36+HZ4yz8Q8kBvpS39gzgh8NaZ5eMjBMlIJ/z4SFLR1y8xxCPRzS95+psbkIBZAuK5+qxu",
	"Z25IuIxA8iDSfN2ORnwfvAUIT8QYR8PfPvA/DCQzmRjmV4zUm9IY9h+YWO+XiqlECgf6ejYrO2UWwSSA",
	"OqWIPJWfF00Kz6u44XdlmzDuDVRmInPmjdxFOlURxEEAiIjFFBPhy4RcBgNo45eczLkx6eiPhZz0B7RA",
	"VE16KNuFctJ1+iLxNxFXZuSBJnLSo2zSMxNVRCLyAFSSoyzdC1azr7maxBBT0a+ZBMnggjjngtjkgiSb",
	"fk73PE0SzbkgzbhA2jD/3IEL1GwciQe2KEerS2rhQDySphO7zIOqjaOC8USpJ1+84ATC2EL17iXRqh6j",
	"+TGgOQ4QBZMQBrtdOdREL+JiCiZ01z6UP+1hbzyyWniVmnWyRp2u+VIljE8CuILq4k3+3L6RRJDS7HbJ",
	"/rJqsuVNQ6Xc9XZKS55x6ScKgT8PQDT/qeHx//U4XGfUKdQ9/BoMOrbC39sac7I+9rHmWAtRfx2WnD0q",
	"9tcMG4m29suS0GT/0uzHzNG74erJTUFf+PRZXlh/wZOnjVH2O3W+tF6OegjdbdXlx1Fz5WWXamLtZefU",
	"Xal6ENm2d6X7o4ilEx1PrULtKzma7i04S6kXcq7WK0ata0EwOZ3ZzVeRCDU3/6T5xZyk+02ktFnnbTee",
	"yff1St3WYRAgqX87Wm1YvRGb1wVGDGFmQc9UqPOUwoSeZ8qVq6MK3RGJoMPgEz/P6JikVVpYOTqv0Wh1",
	"Ol6j0252G16n0Wh7+S33T+/TB0D//JkkJID+A/opJmE9v57P4+KsiOeNFeal3l7Cfw1w+zDag27La/U6",
	"fW8w6BnD+FvsuzX3b2SSBmQhazmaRuhWs9sc9Dv9UuzdxuM4l9fkkJ5XkGi7VVitXr/T2EiTWG/P+ZD7",
	"RFxulsI3u98/vE0i9yzY4SyaDbhqsjAcPybbDvLAR+49hwjXHmumkGsHUrXgJxpRz3/dccaIQqvuCOoh",
	"lzWLOfJlLWIBgjoxQHZXuDynmKVD8SxzrIN297fsdmuFlwt/6MQJ9BEVpZuz3lT/9Q0LkWii2rxKt3Ar",
	"lVVnV3mRNk0vUtHvYdxIV/qR8kemMc8oSVshqN57TJ8NWQBdlpi12BtW9HSXO4FoZRfDJ+ZQKKY7gTQN",
	"Gd3SksDRu+N79g2YWXxwcvSRvHXQJbHLmkzMX6+Oha3p+m5VNw54BCgEkxBuy2Yf5Lzfqury1XOdH6dj",
	"YSs1T9PTkACWQ5LYyFMTfRjTGPhwjPB4NrFnZ1rlcxTBiCTL/M2X4W0TAK6HrBS9dcZB5SJWMgdOlo6k",
	"UnXWKp5wWx1lCxjlVr21Hm7HAKC81yrZ+oTgH0tqbAyzZIRdnSZNOT1u2b3cAHXnlmrPm3LAlVKUTdfj",
	"zM+77IJsI0bVDFwS0lwB1C9SJwJLBxMmy9InzPn57u6mWRMyic2RENl8f+V/VZ+yiTCQmN58uvJ5fleZ",
	"e7PgNAwttuUiYrxbRz1VxfH5hi2d1VVdbIkPx0uP4AU8IhB/knN7n6kwRaSUsbq66n69fa/3zZXAlO9F",
	"SUfSPjxaq1XevnUMJSeYLsBuleM+fbaaTSSL/UAdFNScKKWMU0jaUWpiQ1Es4/zwSalW92efZN/3P2yH",
	"eNk9ueaieErHM8DgAizXWkKvb96NHN2Qz9YUMn8uIxD4oZOjHjLE8cxacR5EkcicLw9scvtAIWLLrE+x",
	"CtaNQsqN8vQaBp3qFKuHzmIOE2hcrjhc4ogbeqEOb085Fe8AIsgUr/sE+2mSQKySJo41R6/ALNtR8xed",
	"25s3pYUAnaEEqIlZd66kAnThNNavjFSGLynEG8+Z0jVOjN0332+9ese2obbL+6RX7zw/5+7a5cF9BBEs",
	"3mRtR2DNks/3Vaf5V3F4JHH4b5Imjj4EOwhTBrAPMyEkA50QJ8YjAg5wpMWAS9CaOhXBp5hQSJ0l7ykk",
	"Pgjzbog0nAl6K75fktShMIQ+qzv/JqnjA+yklFMgeUQ+pE6IHqCDZwl5cP6uxaz4ys+X/9hRTgckAgjX",
	"ZT8gjnNhXQ2KMKW1Jv5fjnC5Wbv2pbesUnzKyQW/SYqi5N9JrDaaNrlac7VNxRI5Z3ABmwMmRqWxyv0L",
	"JI87CxSGYs+G2CG47txxIULnJA0DwZg4P8NlxBKwt9hTlERJYAiW4zQJx6JeWAX590pzEO3kTSpXG0gY",
	"koVwg0igD9Ej1Fft1FHG6zWI2HSBI25KkufklqROLa970TH3otvR6Od0kkvCX2/fbzVjmiGEcM+qtm0v",
	"2g+CxxeXnZIAmeR8SWA1rRLLqwqsZuf0clhHB5alMKgEaxfDs0vnGfHMeYAi8l22lFuwnPH1nG3ntlPI",
	"H0tQ5BYOB0VT1BY2ixXRgF/AVrND8GQOpVL15KXhbw/S4rVe2rK2ve74SAJoiVf3ySNMMt+1kjlQ7Sgq",
	"/7tySx1rn9Xsu1lrU/0mOO1eFD81+xAOpuPcv1OVvBxr982yubDwslZSVOe55a/QSi5s3UaULeD9ERk4",
	"05kG06DfaIGg6YGBNwHeoNcMgpbnAX/g9Rp+c9Cd9DsNEXnskyQQAEJAGd/1EjaBgMlLw16/0+32RDN+",
	"WM+P6Z/coivo+ebhOv+UV9DjEEWI/dj5b+p5zW7m0vMjSZn8ST5vddxaGRaQbgq0+sR7etvtT0Bw9bbZ",
	"ueq3+gMA25NBd9BtDt90mt2rRqM1bV2CN4Orf8rum54EpmTvjzoQSf7KwOzHYhRRBV570PBak4HXvZp2",
	"m8PLXs9rtftXbxqtSb/R63YHvdZlt+s3Ghk8zjAZORdAEJ/vrTHx5+5Fq93Tk8lplLVwm17fEgAn3Rsg",
	"ZWNFkQtXFNhU6YGM9z3pZ6KhdO1QWu3OZlAaXnsVmPuaS0NA5zAY6xJNArqbxiKf6UWj0+x12zX3ESZU",
	"bT8+icSVmttrtHs+9F0dw/XYqDfrniW+3VzSL9j7i4+NdbRNLt7CGt/8RZvcLCz+AyBng2G9LjhQ7zZ4",
	"ufyx+u6qpw58jLJLYrXF46LDsZmrORNNm2wmt6q5wWir7+hkCxMFB2GHQp/ggNqdlQxu3QSd31Tz9Tun",
	"2q70Pcce2ore+NbCuylogaWL/Rjtnp2nZlEpN+mllDXoueZKe/AEMH8+puhPuCs+2q7sQxQzerAOs5JX",
	"u3exWVbvVX2sNZ3v0uEBSVQ1bhw26sH0S9rOd25VXOLOHqP3JloV7+Lj5T8UqToNN2YbHtu7GO6Qoj+L",
	"Lfhc8ILSbof1rMWh6lpncRDPe/o9rmav0nHkyLOYnXrutz/nmP7DR0ZTuCjvg6Jy8j1WQlARqlriQtlb",
	"/U568R6E/yTbbUuE29Foz6CmT+5isaiDiV/HkNVBujbpoQD3dYQyGSPfIYjpdjTaJ3zpdjT6fgOXuGq/",
	"ZdRScTKO53av86iu3cUVk34loUr5kvkLBikV+eI1PCk0jeZbBycVqbmnzPpqApJycXOiaKSSsPqm45BM",
	"gfh1BCKZO+sJqojcjkYHj1OSBlOVUextFAHn9yXG0ALnv6nntfwAPYoPUH6dN+W3a+zQOUnYhfz5XP8u",
	"v8byy0fkz2GIHhGeOX5KGYlg4rxBOFg6t8ifgySgBDsULKlD5yLOgTzCZDGHYaRTC/uEMlpzEPbDNOD9",
	"8MN7zYlIwmZgBuWtvrjeC+T9tZB6BM+cgJ+nqcMnJITCWX0OE2dOUgrrCunYgvNI5iN2QByHSFJUXdrx",
	"12kawwRgnMqAD4IdMYo5ip1ZQlIcUGeSMpF4J4Gce2BgBabJ9fscsB+ocN7/5zpK/j50RLXHxIfOB4QR",
	"ZTBxRil03oYhTJacdHyxgvBBrlyZJpJEMcBLB0xIypwEUhI+aqd9QSJNG4I1tSLeXk8VdUACnSnwEZ5Z",
	"R3GeMwd2zWqZbtNrts+83pnXvPPaF43WRatf9zzvP27m2e5KPpApiuKYUEnrCd+zBJZcn3YwXDhzEkFn",
	"snQwWdSda0wZBAHnlx+ows2ZAPyQpDHzl+4LutP64Cx1I/tCrFJC6eFDsRK5/Wx9RMrNvJb81fIhl+rC",
	"SJuHz1RPJ+X7K6sGCShzsja6W/uuULnzWoEgxCx3+zB6zNRQ21uiuV7scmgxqm9ymijfHa3FSrSxIrWZ",
	"SV2UGbAVPC9d8NiQUG0c2cZC600CQvLSXbZR8mdmx6Ubd3nZZU1Xwh9JPyveh50B9K3FelpndxsGtSu9",
	"mrcaxZu0dewh27zQYeUOzjoXstFGOK6bjtGqNG63KpLNDHCbAC4R+fYo31Jpnas53JTQUDv6SLYyoN5l",
	"4WwvgdQHEyqC78TmB2Z/p//YlvPLeeL280q4MzVni/6qH/NpWcxhqdoE8YXB38akRameymKcJuBlDHd3",
	"y1CmtX1H/1t+cVYd+wwxR92siTjU1atZXxGv6kU+XyNmspOR/X0GZjvKqDx6GODlrpcSqpOtryT0e/cV",
	"hPIgOrsj0q63PGjndFqVuJldOrE55G3STzmacvskm2VMij51G62s/I2CA9xhr8mM7PWFE16p5vzeGUa3",
	"tXAUzBuqwME2vmn5xqDjmzeyQvC2W1M7W45m3Yc14ajXVzahselqltBuEjITsfXVg6zaw1lqSXz3Ah9k",
	"vVYEQaFIyGq7nK9D8CsgDV2pVPhiZW8wEOOAL/VXrIhhV5J4i016e3mtjDJuXDnBeUmK6qHrmo9MnrJ0",
	"vY5f8RyCkM1fTBuh0B5p1eggZ7HNz2GcFNBPE8SWI96D5IwJBAlMhikT6rPoWuhr4uecwnPGYsHlLlLC",
	"pqShjUYt5yM/3Axvrmsy7PGPlB/2swicOCGPKJDKTYh8iGUFOKUKfri+c5XnexaXJBJuylBvkszO1Uv0",
	"nLfNo85dDdY1PHfcRt2re0q1xyBG7oXbqnv1lqwLMRdjPwcziBnH9fwz//GZ/6gcNlYooDoIfZqQqKR+",
	"8h7qruFsdx24F+6/IBtyKFfygtzcSFboDnkT4+OY9z4GSFag0TkYOKJNz1sl6bJ2+afx8PpWfebEaW/3",
	"8iUIbuWBRb7c3ublj4S9IykWh8zOdnCvORtjEL5VMZA5Jwsqmjz8SQSjZMX5Of0dMQEOnwFnsnRu+BLL",
	"M/cMr6Vb7SrHU74oCV3HE8AR/jSlnB/lsmNZ+G/OMRqGvv8oVumhS8pgVAxnewQJIilVSytnDxE5hEIG",
	"E2Fj1Ok6RK8qv4ZplhQOqlTH0VlTlvBulOm5lh9baK10wqs52eVXTbwTkQRWV8ENocyWGZvmDqeXIk/T",
	"Kp7QTRA0vy3Hl5zy/4L2zofZcOQ+s/uqsRXiQJAebCmdbj0IgjliVWjuM8iUL4vCiK0rxLzoP9YKifIs",
	"Ln+1FWJ4VR1+hejOX1fI+hWSTfbl0jEmZPNFohW3z+rDBioGKDg/aGtXVd8orgXVv4pozcJeQRiShQjh",
	"MheAYbhbZivGWCs09ecOoHIVGMxd5e3VDF1muY/ZFeh+OhA2bvI3f1WIAxmHstObZiDLTh2o5Fi7vEoR",
	"9uGYGVfs2/eRYobCPfugmePB9u8GhqfL9m8z5aqw9XvaY3DbF7W9Y1xKgn//dQvJb0YjV8JgV9VDT8/5",
	"Z/3paHJVA/h6Batxu7ufZF3F9K+C9lXQHkvQYsMz/lWyHkCyammwq2hlT+efUbCNJaxyD5tdZ0pL+Xrp",
	"dfd0fbW/XUxBHKPgywgd1UEMZvAorLz8CxrtNBdNOCNtxcOflWFtNRcX93Kdm5eat/E2CwWoGu++f8vE",
	"CuvaARat6OdV2/jLahv7HOVfj4TfnbyX8nRjvSXLrfBF7moy6N+dFbpcIuZgdzSVjg9nfS5Xxvq+72ay",
	"0VZWwhHNzTnDf42m5owkr2bmV33k2zMzG4Vf7r9eSfh9mJdXS8+jmpVz+flVmpSriU8OZk42qxq9CtNX",
	"YfqVm5JfJeiLZuTVIvQE5uMM+Kvp+CXWfTUbb8KzX8Jc/H2aDyyH/IOZiV+1iFcT8etx7tU0/JIuojiG",
	"nvtZUOR6TaRYZVAGz0jBaLxArcJOp0NX8Zf7TXUhtfxXab2sTIyVdMbciMBEOS06dp6+PCEiR4IKgVNq",
	"op36JIC/qG4FJDv9fYIZlHFvDD4xfspHOAt2Airqig9b7/RIJM7LQ5pUUYaA6xTe0yfvbADOpsOzd/ef",
	"296zPRiwXOjANqSvemoFxpq6jiLvunk9zzTpLMxwg2kuhNytnW2t2L1RWsULUy0y4shcw+f/o6Q84aV4",
	"85VxkTalqZCpqNFsN71Bs+v1bbGNIlFJGgc6BfiKNCUiQ3UhE4AUeAtAHfV2Ie8a/+VMJL7eIHq9yo3D",
	"IhStzwZa6ZumYbj8FvgzG4hmirUMqiMXDyd91kidzXdV2c23IfAF1bMA1rXUliubjvPw74OKAxnNSzNc",
	"9pmDPIr+G5oFifTayUgoPURg6+1otDq49XY02vuIl6hA+H3mME81+pdUkfkcmaaPUpArnyVZJYnC5FFP",
	"U6kenSiyGMBHGJI4gpg5sm0hLPvi/FwUY5wTyi76sgSIArKStaR7nGQvMhWoFjdTFQIuEgjWNu2m6HBn",
	"7fCq4lm2Wde5ccba7buCJWKzLofXIibe6GV47T7fP///AAAA///SbJVi2CkBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
