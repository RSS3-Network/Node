// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/rss3-network/node/v2/schema/worker/decentralized"
	"github.com/rss3-network/node/v2/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/metadata"
	"github.com/rss3-network/protocol-go/schema/network"
	"github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// PostDecentralizedMetadataJSONBody defines parameters for PostDecentralizedMetadata.
type PostDecentralizedMetadataJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit    *int                   `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Metadata *metadata.Metadata     `json:"metadata,omitempty" validate:"required"`
	Network  *network.Network       `json:"network,omitempty" validate:"required"`
	Platform decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool        `json:"success,omitempty"`
	Tag    *tag.Tag     `json:"tag,omitempty" validate:"required"`
	Type   *schema.Type `json:"type,omitempty" validate:"required"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostDecentralizedMetadataJSONRequestBody defines body for PostDecentralizedMetadata for application/json ContentType.
type PostDecentralizedMetadataJSONRequestBody PostDecentralizedMetadataJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Agent Data by Path
	// (GET /agentdata/{path})
	GetAgentData(ctx echo.Context, path string) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Batch Get Activities By Metadata
	// (POST /decentralized/metadata)
	PostDecentralizedMetadata(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Operator Info
	// (GET /operators)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /operators/activity_count)
	GetActivityCount(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAgentData converts echo context to params.
func (w *ServerInterfaceWrapper) GetAgentData(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAgentData(ctx, path)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// PostDecentralizedMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedMetadata(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/agentdata/:path", wrapper.GetAgentData)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.POST(baseURL+"/decentralized/metadata", wrapper.PostDecentralizedMetadata)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/operators/activity_count", wrapper.GetActivityCount)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"nHijl/Gl+3j7+P8CAAD//0gbDb2sKgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
